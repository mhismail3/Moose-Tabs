## Component Hierarchy

- SidePanelApp (Root Component): The main container rendered in Chrome’s side panel. It manages high-level state (like the tree data and UI settings) and provides context to child components. It also initializes by fetching the current tab tree from the background script on load.
- Header Toolbar: A top section with controls: e.g. a search bar for tabs, buttons for “Collapse All/Expand All”, and possibly a toggle for settings or theme. The search field filters tab nodes by title/URL in real time.
- TabTree (Container): A scrollable container that renders the hierarchical list of tabs. It receives the structured tab data (possibly as a nested array or flat list with parent IDs) and maps over it to display TabItem components recursively.
  - TabItem (Leaf Component): Represents a single tab in the tree. It displays the tab’s favicon, title (or truncated title), and possibly an indicator for loading or audio if tab is playing audio. Its indentation level reflects hierarchy (e.g. via CSS margin or a tree line). If the tab has children, TabItem includes a collapse/expand arrow icon that, when clicked, toggles visibility of its child list. A TabItem might change style if the tab is active, hovered, or if it’s collapsed vs expanded.
  - Child TabItems: If a tab has children and is expanded, a nested <ul> or nested component list of TabItems is rendered underneath it (with additional indent). If collapsed, the children are not rendered (or hidden).
- (Optional) Footer / Status Bar: A bottom area (if needed) to show count of open tabs, or a “New Tab” button that opens a new blank tab (as child of a selected parent or as root if none selected). This can also house a language switcher if needed for i18n, unless language follows browser settings automatically.

Note: The component structure will leverage React’s component composition. Styling will be done with CSS (or CSS-in-JS) to achieve the retro-futuristic theme (e.g. bold typographies, neon highlights) while remaining clean and minimal.


## Responsive Design & Breakpoints

- Sidebar Sizing: The UI is primarily a vertical sidebar and will typically be around 300px in width (default for Chrome side panel). It should gracefully handle being resized wider or narrower by the user. For example, at very narrow widths (<250px), the tab titles should truncate with ellipsis and important icons (collapse arrows, favicon) remain visible. At wider widths (>400px), the layout can simply show more text or possibly a two-column layout if designed (though likely not needed; a single column list is default).
- No Mobile Support: Chrome extensions do not run on mobile Chrome, so no mobile breakpoint is required. However, ensure it works on various desktop screen sizes and high DPI displays (use vector icons/SVG for clarity).
- Height Responsiveness: The tree should expand to fill available vertical space in the side panel. If the sidebar is pinned and the browser window is resized vertically, the TabTree container should flex accordingly (using CSS flex or height:100%). A scroll bar appears if tabs overflow.
- Window/Panel Placement: The design should allow Chrome’s setting of left or right side panel. All UI elements should look correct in either placement (e.g. if there are any shadows or triangles, they shouldn’t assume a particular side).

## Accessibility Requirements

- Keyboard Navigation: The tab tree must be fully navigable via keyboard. Users should be able to focus the sidebar (e.g. by pressing a keyboard shortcut or clicking), then use Arrow Up/Down to move between tabs, Arrow Right to expand a collapsed branch (or move to first child), Arrow Left to collapse an expanded branch (or move to parent). Pressing Enter or Space on a focused tab should activate (switch to) that tab in Chrome.
- ARIA Roles: Use proper ARIA roles for a tree control. The container should have role="tree" and each tab item an element with role="treeitem" . Groups of children can be wrapped in an element with role="group". Manage aria-expanded attributes on tree items that have children to convey collapsed/expanded state to assistive technologies.
- Focus Management: The focused tab in the sidebar should be visually highlighted (e.g. a focus ring or distinct background) to aid keyboard users. Ensure that opening/closing the side panel sends focus to the panel or a logical starting element (like the first tab or search box) rather than trapping focus elsewhere.
- High Contrast & Scaling: The UI should maintain sufficient color contrast for text and icons against backgrounds (meeting WCAG AA contrast ratios). Provide a setting or just inherit Chrome’s high-contrast mode settings if possible. Font sizes should be relative (e.g. rem units) so that if a user zooms the page or has system text scaling, the extension UI scales accordingly.
- Screen Reader Support: All interactive elements need descriptive labels. For example, the collapse/expand toggle can have aria-label="Collapse tab children" or similar, updating to “Expand” when collapsed. Icons should either be hidden from screen readers if redundant (using aria-hidden ) or given a label. The extension’s name and role (sidebar) should be announced when it opens. Internationalization support ensures these labels are also localized.

## State Management Approach

- React State & Context: Use React (with functional components and hooks) for UI state. The tab data (the tree) is likely large and frequently changing, so centralizing it is important. A context or global store (like using React Context or a lightweight state library like Zustand or Redux) can hold the tab tree and provide it to components to avoid prop drilling. For example, a TabTreeContext could provide the list of tabs and a dispatcher for actions (expand/collapse, etc.).
- Sync with Background: The front-end will obtain the initial state by querying the background (e.g. via chrome.runtime.sendMessage({action: "getTree"}) ). For ongoing updates, the front-end can subscribe to changes via messages or events. One approach is for the background to send a message (or use the chrome.storage.onChanged event if using storage) whenever the tab structure changes, containing the diff or updated tree. The React app will listen (perhaps in a useEffect hook attaching a message listener) and then update its state accordingly (e.g. replacing the tree data or applying incremental changes). This ensures the UI stays in sync with actual browser state.
- Local UI State: Certain UI-only state, like which branch is collapsed, can be managed in React state as well. Collapsed/expanded status could be tracked per tab ID in a state object. This might be initialized from saved settings (so a returning user sees the same branches collapsed). Toggling a branch updates this state and can optionally inform the background to persist it (though not strictly necessary to inform other windows if each window keeps its own collapsed state – however, since requirement is to sync across windows, even collapse state could be shared so that collapsing in one
window collapses in all).
- Performance Considerations: Use React efficient rendering practices since a tree with hundreds of nodes could be heavy. Use keys for list items, and consider virtualization (rendering only visible nodes) if performance lags with very large tab counts. Avoid unnecessary re-renders: e.g., when one branch updates, only update the components in that branch. A diff algorithm or shouldComponentUpdate (or memoization) can be used on TabItem to prevent full re-renders of the whole list on minor changes.
- Error Handling & State Recovery: The front-end should handle cases where the background is unreachable or returns an error (e.g. log and perhaps prompt the user to reload the extension). If the tab tree fails to load, show a friendly message rather than a broken panel. Any desync (mismatch between actual tabs and shown tree) can be corrected by a manual “refresh” action (e.g. a refresh button in the header that re-queries all tabs).

## Internationalization

- Locale Setup: The front-end will use Chrome’s i18n API for all text. For static text in HTML/JSX, utilize __MSG_name__ placeholders in the extension HTML/manifest or use chrome.i18n.getMessage in scripts to insert localized strings. We will include a default English (en) messages.json and additional locales (e.g. es, fr, etc.) as needed.
- Dynamic Content: Ensure any dynamically generated text (if any) is also localizable. For example, if showing a status like "X tabs open", the format should come from a message with placeholders.
- Testing: The UI will be tested with different locale settings to verify that text fits within the design (e.g. German or French strings which are typically longer). The design (especially the sidebar width or truncate behavior) should account for this.
- RTL Support: Although not explicitly requested, by supporting i18n we should also consider right-to-left languages (Arabic, Hebrew). The CSS should accommodate dir=rtl if the browser locale is such (Chrome i18n system can provide @@bidi_dir if needed). We will ensure the layout still works (for instance, indentations and arrows might need to flip orientation in RTL).